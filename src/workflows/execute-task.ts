// src/workflows/execute-task.ts
import {
	type WorkflowEvent,
	type WorkflowStep,
	WorkflowEntrypoint,
} from "cloudflare:workers";

import type { RunRecord } from "../models/run";
import {
	type WorkflowEvent as TelemetryEvent,
	WorkflowEventBuilder,
} from "../services/telemetry";
import {
	Backup,
	OpenCode,
	Run,
	Sandbox,
	type TaskParams,
	type TaskResult,
	type WorkflowDeps,
} from "./helpers";

/**
 * Workflow that executes OpenCode tasks durably inside Cloudflare Sandboxes.
 *
 * IMPORTANT: Workflow steps must return serializable values only.
 * Sandbox instances (DO stubs) are NOT serializable and must be
 * obtained fresh in each step that needs them.
 *
 * This is the core of the MCP server - it:
 * 1. Creates the run record in R2
 * 2. Ensures sandbox is ready (restore backup, clone repo, configure proxy)
 * 3. Starts OpenCode inside the sandbox and executes the task
 * 4. Gets the session title (auto-generated by OpenCode)
 * 5. Backs up session state
 * 6. Completes the run record in R2
 */
export class ExecuteTaskWorkflow extends WorkflowEntrypoint<Env, TaskParams> {
	/**
	 * Build workflow dependencies from env.
	 *
	 * Note: No secrets here - all authentication is handled by the proxy
	 * using JWT tokens passed in TaskParams.
	 */
	private getDeps(): WorkflowDeps {
		return {
			sandboxBinding: this.env.Sandbox,
			sessionsBucket: this.env.SESSIONS_BUCKET,
		};
	}

	async run(
		event: WorkflowEvent<TaskParams>,
		step: WorkflowStep,
	): Promise<TaskResult> {
		const params = event.payload;
		const deps = this.getDeps();

		// Create telemetry event builder
		// Constructor: (workflowId, runId, sessionId)
		const telemetry = new WorkflowEventBuilder(
			event.instanceId, // workflowId - the workflow instance ID
			params.runId, // runId - our run tracking ID
			params.sessionId, // sessionId
		);

		try {
			// Step 1: Create run record in R2 (doesn't need sandbox)
			await step.do("create-run", async () => {
				const run: RunRecord = {
					runId: params.runId,
					sessionId: params.sessionId,
					workflowId: event.instanceId,
					status: "started",
					task: params.task,
					title: params.title,
					model: params.model,
					startedAt: Date.now(),
				};
				await Run.createRun(deps.sessionsBucket, run);
				return { created: true };
			});

			// Step 2: Ensure sandbox is ready (restore backup, clone repo, configure proxy)
			// This is idempotent - safe to retry if workflow step fails
			const sandboxResult = await step.do("ensure-sandbox-ready", async () => {
				const sandbox = Sandbox.getSandbox(deps, params.sandboxId);
				const result = await Sandbox.ensureSandboxReady({
					sandbox,
					sessionId: params.sessionId,
					bucket: deps.sessionsBucket,
					proxyBaseUrl: params.proxyBaseUrl,
					proxyToken: params.proxyToken,
					repository: params.repositoryUrl
						? { url: params.repositoryUrl, branch: params.branch }
						: undefined,
				});
				return result;
			});
			telemetry.setMetadata({ sessionRestored: sandboxResult.restoredBackup });

			const workingDirectory = sandboxResult.workspacePath;

			// Step 3: Start OpenCode and execute task
			const executeResult = await step.do(
				"execute-opencode-task",
				{
					retries: {
						limit: 3,
						delay: "10 seconds",
						backoff: "exponential",
					},
					timeout: "50 minutes",
				},
				async () => {
					const sandbox = Sandbox.getSandbox(deps, params.sandboxId);
					return OpenCode.executeTask(sandbox, params, workingDirectory);
				},
			);

			// Step 4: Get session title (auto-generated by OpenCode)
			const title = await step.do("get-session-title", async () => {
				const sandbox = Sandbox.getSandbox(deps, params.sandboxId);
				return OpenCode.getSessionTitle(
					sandbox,
					executeResult.opencodeSessionId,
					params.proxyBaseUrl,
					params.proxyToken,
					workingDirectory,
				);
			});

			// Step 5: Backup session state to R2
			await step.do("backup-session", async () => {
				const sandbox = Sandbox.getSandbox(deps, params.sandboxId);
				await Backup.backupSession(
					sandbox,
					params.sessionId,
					deps.sessionsBucket,
				);
				return { backedUp: true };
			});

			const result: TaskResult = {
				success: executeResult.result.success,
				output: executeResult.result.output,
				error: executeResult.result.error,
				title,
				opencodeSessionId: executeResult.opencodeSessionId,
				workspacePath: workingDirectory,
				tokens: executeResult.result.tokens,
			};

			// Step 6: Complete run and update session in R2
			await step.do("complete-run", async () => {
				await Run.completeRun(deps.sessionsBucket, params.runId, {
					success: result.success,
					output: result.output,
					error: result.error,
					title: result.title,
				});

				if (result.opencodeSessionId || result.workspacePath) {
					await Run.updateSessionAfterRun(
						deps.sessionsBucket,
						params.sessionId,
						{
							opencodeSessionId: result.opencodeSessionId,
							workspacePath: result.workspacePath,
						},
					);
				}

				return { completed: true };
			});

			// Emit success telemetry
			telemetry.setOutcome("success");
			this.emitTelemetry(telemetry.finalize());

			return result;
		} catch (error) {
			// Record error in telemetry
			const errorName = error instanceof Error ? error.name : "UnknownError";
			const errorMessage =
				error instanceof Error ? error.message : String(error);
			telemetry.setError({
				type: errorName,
				code: errorName,
				message: errorMessage,
				phase: "execution",
				retriable: true,
			});
			this.emitTelemetry(telemetry.finalize());

			// Handle errors and still complete the run
			const errorResult: TaskResult = {
				success: false,
				error: error instanceof Error ? error.message : String(error),
			};

			await step.do("complete-run-failure", async () => {
				await Run.completeRun(deps.sessionsBucket, params.runId, {
					success: false,
					error: errorResult.error,
				});
				return { completed: true };
			});

			return errorResult;
		}
	}

	/**
	 * Emit telemetry event as wide event log line
	 */
	private emitTelemetry(event: TelemetryEvent): void {
		console.log(
			JSON.stringify({
				level: event.error ? "error" : "info",
				type: "workflow.event",
				...event,
			}),
		);
	}
}
